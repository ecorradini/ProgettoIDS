private ArrayList<Tronco> UCS (Tronco partenza, HashMap<Integer,Float> pesiTronchi, ArrayList<Tronco> tronchiUscita){
        private class PercorsoConCosto{
            private ArrayList<Integer> percorso;    //deve partire con una lista vuota
            private float costo = 0;

            public ArrayList<Integer> getPercorso () {return percorso;}

            public void setPercorso(int nuovo) {
                this.percorso.add(nuovo);   //non sono sicuro sia giusto
            }

            public void setCosto(float costo) {
                this.costo = this.costo+costo;
            }

            public float getCosto() {
                return costo;
            }
        }

        ArrayList<Tronco> adiacenti = partenza.getTronchiAdiacenti();
        ArrayList<PercorsoConCosto> frontiera;
        boolean guardia=true;
        for (int i = 0; i < adiacenti.size(); i++)    //ciclo di inizializzazione della frontiera
        {
            frontiera.get(i).setPercorso(adiacenti.get(i).getId());
            frontiera.get(i).setCosto(pesiTronchi.get(adiacenti.get(i).getId()));
        }
        while (guardia)
        {
            for (int j=0;j<tronchiUscita.size();j++)        //ciclo di arresto
            {
                for (int k=0; k<frontiera.size() && guardia==true;k++ )
                    if (tronchiUscita.get(j).getId()==frontiera.get(k).getPercorso().get(frontiera.get(k).getPercorso().size()-1))
                    {
                        guardia=false;
                    }
            }
            
            float paragone = 2;       //lo inizializzo a due perché i pesi e la formula in generale dovrebbe dar valori in [0;1] : così non dovesse essere basta cambiare
            int scelta = 0;           //il valore a un opportuno valore sempre maggiore del peso massimo possibile
            for (int i = 0; i < frontiera.size() && guardia==true; i++)       //ciclo di ricerca del tronco da espandere
            {
                if (frontiera.get(i).getCosto() < paragone)
                {
                    scelta = i;
                    paragone = frontiera.get(i).getCosto();
                }
            }
            
            frontiera.get(scelta).setPercorso(); = /*getTroncoByID */(frontiera.get(scelta).getPercorso().get(frontiera.get(scelta).getPercorso().size() - 1)).getTronchiAdiacenti();
        }
    }